我们在一个int类型为32位补码表示的机器上运行程序. float类型的值使用32位IEEE格式,
而double类型的值使用64位IEEE格式.
我们产生随机整数x,y和z, 并且把它们转换成double类型的值:

/* Create some arbitrary values */
int x = random();
int y = random();
int z = random();
/* Convert to double */
double dx = (double) x;
double dy = (double) y;
double dz = (double) z;

对于下列的每个C表达式, 你要指出表达式是否总是为1. 如果它总是为1, 描述其中的数学
原理. 否则, 列举出使它为0的参数的例子. 请注意, 不能使用IA32机器运行GCC来测试你
的答案, 因为对于float和double, 它使用的都是80位的扩展精度表示.

A. (double)(float) x == dx;
B. dx + dy == (double)(x+y)
C. dx + dy + dz == dz + dy + dx;
D. dx * dy * dz == dz * dy * dx;
E. dx/dx == dy/dy

-------------------------------------------------------------------------------

为了理解的更好, 当表达式不总为1时:
我们尽量举出使表达式为0的全集, 并阐述数学原理.
本题所使用的你没见过的令人奇怪的数学符号, 参见readme-[数学符号]节

根据IEEE浮点表示的定义, 我们可以得到:
[浮点集] 具有1个符号位 k个阶码位 n个小数位 k与n满足 2^(k-1)-1 > n
构成的浮点集 = 
+/-Σ(e=0~2^k-2){ 
    SEQ(i= 0 ~ 2^n-1){ 
        !!e*2^E + i*2^(E-n)
    } 
}

为了更好的阐述, 先定义术语和概念.
###############################################################################

浮点集:     按照IEEE浮点标准,
            由1个符号位 k个阶码位 n个小数位 所能表示的所有浮点数的集合

浮点域:     阶码位表示的值e所对应的浮点数集合. (以下简称 域)
            浮点集包含2^k-1个域, 每个域包含2^n个浮点数
            其中规格化值所在的域称为规格化域,
            非规格化值所在的域称为非规格化域.
            域继承了浮点集的对称性, 其中大于0的部分称为正域, 反之称为负域
            为了简单我们只讨论正域, 负域的情形全部作对称考虑

记法:       当表示阶码位为e所对应的域, 我们记为域e-bias
            按照这个法则, 对于规格化域记作域E, 而非规格化域记作域-bias
            以阶码位k=4举例:
            非规格化数所在的域 记作 域-15 或 非规格化域
            最小的正规格化数所在的域 记作 域-14
            e=0b0111 的域 记作 域0
            E=1 的域    记作 域1
           
###############################################################################

域可以看作一个等差数列.
设域e-bias为等差数列A.
小数位的位模式转化为无符号整数i, i就是0~2^n-1间的整数. 
我们把i作为数列A的元素下标
A的首项A_0 = 0 (非规格化域)
           = 2^E (规格化域)
=> A_0 = !!e*2^E
A的公差d = 2^(E-n)
根据等差数列的通项公式 A_i = A_0 + i*d
                           = !!e*2^E + i*2^(E-n)
综上, A = SEQ(i=0~2^n-1) { !!e*2^E + i*2^(E-n) }
浮点集是所有域的并集.
即浮点集 = +/-Σ(e=0~2^k-2) {
    SEQ(i=0~2^n-1){ !!e*2^E + i*2^(E-n) }
}

[精度判定法则]
对于非负有理数x
若 x >= 2^(2^(k-1)) 则这个数超出域的范围. 不能被表示
若 x < 2^(1-bias) 则x处于非规格化域 E = 1-bias
若x in [2^(1-bias), 2^(2^(k-1))) 
    寻找一个整数E使得x in [2^E, 2^(E+1)) 则x处于规格化域E中
    根据域的通项公式:
    x = !!e*2^E + i*2(E-n) => i = (x-!!e*2^E)/2^(E-n)
    非规格化域: i = x/2^(E-n) 且 x in [0, 2^E)
    规格化域:   i = (x-2^E)/2^(E-n) 且 x in [2^E, 2^(E+1))
    => 无论如何 i in [0, 2^n) 且决定i是整数的条件是x是2^(E-n)的整数倍
    => x如果是2^(E-n)的整数倍, 则x是域的通项, x亦能被浮点集精确表示
       反之则反之
根据对称性, 对于非正有理数x的判断是同理的.

综上, 判断浮点集是否能精确表示有理数x的方法是:
1. 判断x是否处于浮点集的任何一个域中, 如果不是则不能表达, 如果是则进入第2条
2. 判断x是否是该域公差2^(E-n)的倍数, 如果是则能表达, 反之则反之

根据[精度判定法则], 我们有如下推论:
具有1个符号位 k个阶码位 n个小数位 k与n满足 2^(k-1)-1 > n 所构成的浮点集
能够完全表示的有符号整型数最大宽度w=n+2
证明:
首先 w=n+2的有符号整型数 in [-2^(n+1), 2^(n+1)-1], 
因为2^(k-1)-1>n, 浮点集存在域n+1, -2^(n+1)处于域n+1中
[-2^(n+1)+1, 2^(n+1)-1] 分布在域0~n中 
无论如何[-2^(n+1), 2^(n+1)-1]每个整数都在域的范围中
然后 域的公差d = 2^(E-n) 也就是说[-2^(n+1)+1, 2^(n+1)-1]所处的域公差 E<=n 
1/d = 2^(n-E), 这里n, E都是整数 1/d是一个整数 => 任何整数都是d的整数倍
=> [-2^(n+1)+1, 2^(n+1)-1]每个数都是其所在域的公差d的整数倍
=> 浮点集能表示[-2^(n+1)+1, 2^(n+1)-1]中的所有整数
考虑域n+1, d=2. 而-2^(n+1)是2的倍数 => -2^(n+1)能被表示
综上浮点集能完全表示w=n+2的有符号整型数
又因为当整数x>2^(n+1)时, 若其在域的范围内, 则E>=n+1 域公差d=2^(E-n)>=2
=>不是所有整数都是d的整数倍=>浮点集不能表示所有x
综上浮点集能完全表示的有符号整型数最大宽度w=n+2

A. 
精度判定法则及其推论揭示出:
我们能用double类型, 其小数位共52位, 表示所有int类型的整数; 然而对于float类型, 
其小数位仅23位, 我们能精确表示 [-2^24, 2^24] 间的所有整数, 但不能表示其外的所有
整数. 这些不能被精确表示的数的全集是
(2^24, 2^25)中的奇数
(2^25, 2^26)中不能被4整除的整数
(2^26, 2^27)中不能被8整除的整数
(2^27, 2^28)中不能被16整除的整数
(2^28, 2^29)中不能被32整除的整数
(2^29, 2^30)中不能被64整除的整数
(2^30, 2^31)中不能被128整除的整数
以及相应的负整数
当32位整数x属于以上集合, (float)x将产生舍入, 最终将导致表达式为0.

B. 当x+y产生溢出时, 表达式为0
x, y in [-2^31, 2^31-1] => x+y in [-2^32, 2^32-2]
double类型浮点数能精确表示这个范围的整数, 也就是说dx+dy始终得到数学上的正确结果
而int整型x+y则会产生溢出, 溢出时得到数学上的错误结果, 最终导致表达式为0

C. 1
无论以怎样的顺序对dx, dy, dz进行加法, 其结果都在double类型所能精确表示的范围内.

D. 有点复杂, 我无法找到满足表达式为0的常规模式. 
这里仅举一个反例. 并追踪浮点运算的过程, 显示出: 浮点精度的丢失如何导致浮点运算
丧失结合性. 
x = 0x7fff8010
y = 0x7fff8100
z = 0x7fff800f

a*b表示实数乘法运算, round(a*b)表示浮点数乘法运算, Δ(a*b)表示round(a*b)-a*b
round(x*y*z)的过程:
x*y        = 0x3fff80883f781000
round(x*y) = 0x3fff80883f781000
round(x*y)*y        = 0x1fffa0481f70703fb008f000
round(round(x*y)*z) = 0x1fffa0481f70700000000000 = round(x*y*z)

round(z*y*x)的过程
z*y        = 0x3fff8087bf788f00
round(z*y) = 0x3fff8087bf789000    <---注意此处有精度丢失, 向偶数舍入
Δ(z*y) = 0x10
round(z*y)*x        = 0x1fffa0481f7070bfaf890000 = (z*y+Δ(z*y))*x = z*y*x + Δ(z*y)*x
                    = 0x1fffa0481f70703fb008f000 <---z*y*x
                                  + 0x7fff801000 <---Δ(z*y)*x
round(round(z*y)*x) = 0x1fffa0481f70710000000000 <---由于前一步的误差导致了结果向上舍入

E. dx或dy为0时表达式为0
