我们在一个int类型值为32位的机器上运行程序. 这些值以补码形式表示. 而且它们都是算
术右移的. unsigned类型的值也是32位的.
我们产生随机数x和y, 并且把它们转换成无符号数, 显示如下:

/* Create some arbitrary values */
int x = random();
int y = random();
/* Convert to unsigned */
unsigned ux = (unsigned)x;
unsigned uy = (unsigned)y;

对于下列每个C表达式, 你要指出表达式是否总是为1. 如果它总是为1, 那么请描述其中的
数学原理. 否则, 列举一个使它为0的参数示例.

A. (x>y) == (-x<-y)
B. ((x+y)<<5)+x-y == 31*y+33*x
C. ~x + ~y == ~(x+y)
D. (int)(ux-uy) == -(y-x)
E. ((x>>1)<<1) <= x

-------------------------------------------------------------------------------

为了理解的更透彻, 当表达式不总为1时: 
我们尽量举出使表达式为0的全集, 同时阐述数学原理.

A. 当x=-2^32 或 y=-2^32 且x,y 不同时等于-2^32时. 表达式为结果为0
显然, 在数学中, ==运算符的两端是恒等效的. 
然而, int类型值为32位补码表达的整数集是有限的, 且具有非对称性. 这就造成了: 在补
码中并非所有的数都能在0的对立面找到一个相应的负值. -2^32就是这个特殊且唯一的数,
-2^32的负值竟然还是它本身!
1. 当x=-2^32且y!=-2^32时: x>y总是0 -x<-y总是1 (x>y) == (-x<-y) 总是0
2. 当y=-2^32且x!=-2^32时: x>y总是1 -x<-y总是0 (x>y) == (-x<-y) 总是0
另x,y同时为-2^32时: x>y, -x<-y都是0 (x>y) == (-x<-y)总是1
  x,y全都不为-2^32时: x>y和-x<-y是等效的 (x>y) == (-x<-y)总是1

B. 1
补码算术运算实质上是在进行模2^w运算
算术左移5位等效于乘以32
((x+y)<<5)+x-y在补码运算中等效于
((((x+y)mod(2^w)*32)mod(2^w)+x)mod(2^w)-y)mod(2^w)
= (((x+y)*32)mod(2^w))+ x mod(2^w) - y mod(2^w)
= x*32 mod(2^w) + y*32 mod(2^w) +x mod(2^w) - y mod(2^w)
= x*33 mod(2^w) + y*31 mod(2^w)
等效于补码运算的 x*33+y*31

C. 任意x,y 使表达式为0
~x + ~y = (-x-1) + (-y-1) = -(x+y) - 2
~(x+y)  = -(x+y) - 1
-(x+y)-2始终不等于-(x+y)-1

D. 1
无符号数运算和有符号数运算位级操作是一致的
(int)(ux-uy)等效于 (int)ux - (int)uy 等效于 x-y 等效于 -(y-x)

E. 1
((x>>1)<<1) = floor(x/2)*2 <= x
